<?xml version='1.0'?>
<feed xmlns='http://www.w3.org/2005/Atom'>
	<title>weweng.github.io</title>
	<link href='http://weweng.github.io/'/>
	<link type='application/atom+xml' rel='self' href='http://weweng.github.io/atom.xml'/>
	<updated>2019-08-16T15:55:22-07:00</updated>
	<id>http://weweng.github.io/</id>

	<author>
		<name>Wenwei Weng</name>
		<email>weweng@gmail.com</email>
	</author>

	
	<entry>
		<title>Jekyll update for my blog site</title>
		<link type='text/html' href='http://weweng.github.io/2019/08/12/Jekyll-Update-blog-site.html'/>
		<id>http://weweng.github.io/2019/08/12/Jekyll-Update-blog-site.html</id>
		<updated>2019-08-12T00:00:00-07:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;My blog site was shutdown for quite a while for certain reasons. However I strongly feel this is a good way for me to capture what I learned along the way and share with anyone who might feel helpful for them. Thanks to all people who provided postivie feedback. After clearup the issue and I finally decide to continue working on my blog site. First thing I do is to update my blog development enviroment which is Jekyll, installed in ubuntu 16.04 VM.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/jekyll.jpg&quot; alt=&quot;Jekyll on Ubuntu&quot; /&gt; 
</content>
	</entry>
  
	<entry>
		<title>Building a Machine Learning platform using UCS 220 M5 with Tesla P4 GPU</title>
		<link type='text/html' href='http://weweng.github.io/2018/09/08/UCS220-M5-ML-platform.html'/>
		<id>http://weweng.github.io/2018/09/08/UCS220-M5-ML-platform.html</id>
		<updated>2018-09-08T00:00:00-07:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;Machine Learning has been a very hot field. Big players like Amazon, Google, they host machine learning infrastructure in the cloud, which is very nice thing, except it can be very expensive to use it. I’m always curious if I can build one by myself: a relative powerful machine learning platform. The following shows what I achieved using UCS220-M5 with Tesla-P4 GPU.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/ucs/c220-m5-tesla-p4-ml.jpg&quot; alt=&quot;Required Hardware&quot; /&gt; 
</content>
	</entry>
  
	<entry>
		<title>GPU Programming With CUDA</title>
		<link type='text/html' href='http://weweng.github.io/2018/01/27/GPU-Programming-With-CUDA.html'/>
		<id>http://weweng.github.io/2018/01/27/GPU-Programming-With-CUDA.html</id>
		<updated>2018-01-27T00:00:00-08:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;Parallel computing using general purpose GPU is really taking off with advancement of technology from Nvidia, AMD, Intel. Especially Nvidia is dominating the field with variety of GPU offering and also software infrastructure CUDA (initially called as Compute Unified Device Architecture), which is a parallel computing platform and application programming interface (API) model. In this article, I share how GPU programming with CUDA looks like using UCS server with Nvidia GPU GRID K1&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/linux/gpu-programming-cuda.jpg&quot; alt=&quot;GPU Programming with CUDA&quot; /&gt;&lt;/p&gt;

</content>
	</entry>
  
	<entry>
		<title>SPI flash support in embedded Linux box</title>
		<link type='text/html' href='http://weweng.github.io/2017/08/05/SPI-Support-embedded-box.html'/>
		<id>http://weweng.github.io/2017/08/05/SPI-Support-embedded-box.html</id>
		<updated>2017-08-05T00:00:00-07:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;Serial Peripheral Interface (SPI) flash memory is often used in an embedded Linux box to hold bootloader. During very initial board bringup, SPI flash memory needs to be programmed properly using device like Dediprog, otherwise the box won’t boot. After the box is up running linux, often there is need to access SPI flash, e.g. upgrade new version of bootloader from linux. I will share what needs to be done for that.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/linux/linux-spi.jpg&quot; alt=&quot;Linux SPI&quot; /&gt;&lt;/p&gt;

</content>
	</entry>
  
	<entry>
		<title>RTC support in embedded Linux box</title>
		<link type='text/html' href='http://weweng.github.io/2017/08/02/RTC-Support-embedded-box.html'/>
		<id>http://weweng.github.io/2017/08/02/RTC-Support-embedded-box.html</id>
		<updated>2017-08-02T00:00:00-07:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;Real Time Clock (RTC) is a small but important piece of hardware in an embedded Linux box. It saves time and keep time valid while box is in shutdown state. When the box boots again next time, it will provide a valid time to Linux system.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/linux/linux-rtc.jpg&quot; alt=&quot;Linux RTC&quot; /&gt;&lt;/p&gt;

</content>
	</entry>
  
	<entry>
		<title>UEFI ARM Linux boot</title>
		<link type='text/html' href='http://weweng.github.io/2017/07/21/ARMv8-UEFI-manual-boot.html'/>
		<id>http://weweng.github.io/2017/07/21/ARMv8-UEFI-manual-boot.html</id>
		<updated>2017-07-21T00:00:00-07:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;For the last few days, I have been working on switching u-boot based bootloader to UEFI based boot loader for a new platform at work. I found out it is useful to able to boot manually with kernel, dtb, initramfs. By doing this, if the thing doesn’t work, we can change any one of them to identify which one has issue.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/linux/uefi-shell-boot-linux.jpg&quot; alt=&quot;armada7k boot manually&quot; /&gt;&lt;/p&gt;

</content>
	</entry>
  
	<entry>
		<title>Linux udev rule to create persistent device name</title>
		<link type='text/html' href='http://weweng.github.io/2017/05/21/udev-rule.html'/>
		<id>http://weweng.github.io/2017/05/21/udev-rule.html</id>
		<updated>2017-05-21T00:00:00-07:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;udev is targeted at Linux kernels 2.6 and beyond to provide a userspace solution for a dynamic /dev directory, with persistent device naming. The previous /dev implementation, devfs, is now deprecated, and udev is seen as the successor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/linux/linux-udev-rule.jpg&quot; alt=&quot;&quot; /&gt;&lt;/p&gt;

</content>
	</entry>
  
	<entry>
		<title>Make a high end UCS Server for fast build</title>
		<link type='text/html' href='http://weweng.github.io/2017/04/27/UCS-install.html'/>
		<id>http://weweng.github.io/2017/04/27/UCS-install.html</id>
		<updated>2017-04-27T00:00:00-07:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;Cisco IOS has been growing significantly over the last ten years. The source code is reaching 10GB, and build time is taking long depending on the build machine capacity. To make development time efficient, it is critical to cut down the image build time. This week, I spent some time to make a high end of UCS server for IOS image build.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/ucs/ddr-cpu-hs.jpg&quot; alt=&quot;High End UCS Server&quot; /&gt;&lt;/p&gt;

</content>
	</entry>
  
	<entry>
		<title>Marvell ARMADA 7K Linux boot using u-boot</title>
		<link type='text/html' href='http://weweng.github.io/2017/03/24/ARMv8-manual-boot.html'/>
		<id>http://weweng.github.io/2017/03/24/ARMv8-manual-boot.html</id>
		<updated>2017-03-24T00:00:00-07:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;For the last few days, I have been working on build new image for a new platform at work. I found out it is useful to able to boot manually with kernel, dtb, initramfs from u-boot. By doing this, if the thing doesn’t work, we can change any one of them to identify which one has issue.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/linux/armada7k-boot-linux-steps.jpg&quot; alt=&quot;armada7k boot manually&quot; /&gt;&lt;/p&gt;

</content>
	</entry>
  
	<entry>
		<title>Linux initrd and initramfs</title>
		<link type='text/html' href='http://weweng.github.io/2017/03/20/linux-initrd-initramfs.html'/>
		<id>http://weweng.github.io/2017/03/20/linux-initrd-initramfs.html</id>
		<updated>2017-03-20T00:00:00-07:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;After Linux kernel boots, it looks for root file system, which can be initrd or initramfs. They are two different ways.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/linux/linux-initrd-initramfs-comp.jpg&quot; alt=&quot;linux init rootfs&quot; /&gt;&lt;/p&gt;

</content>
	</entry>
  
	<entry>
		<title>Linux Kernel image in different forms</title>
		<link type='text/html' href='http://weweng.github.io/2017/03/17/linux-kernel-image.html'/>
		<id>http://weweng.github.io/2017/03/17/linux-kernel-image.html</id>
		<updated>2017-03-17T00:00:00-07:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;Linux kernel presents in different forms depending on the actual context.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/linux/linux-kernel-image.jpg&quot; alt=&quot;linux kernel image&quot; /&gt;&lt;/p&gt;

</content>
	</entry>
  
	<entry>
		<title>Create docker container image</title>
		<link type='text/html' href='http://weweng.github.io/2017/03/04/docker-container-image-creation.html'/>
		<id>http://weweng.github.io/2017/03/04/docker-container-image-creation.html</id>
		<updated>2017-03-04T00:00:00-08:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;Docker is growing with amazing features, and it becomes a platform to deploy services even in embedded linux enviroment. The container image creation is an important part of process.
Docker has done great job to manage the container image to make it to be in layer fashion, this is especially important for storage efficiency.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/linux/docker_container_image_layers.png&quot; alt=&quot;docker install&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The following post shows what I did to create a scratch hello image and a minimal linux image based on alpine using Dockerfile.&lt;/p&gt;

</content>
	</entry>
  
	<entry>
		<title>Install docker from binary distribution</title>
		<link type='text/html' href='http://weweng.github.io/2017/02/27/docker-binary-install.html'/>
		<id>http://weweng.github.io/2017/02/27/docker-binary-install.html</id>
		<updated>2017-02-27T00:00:00-08:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;Docker is growing with amazing features, and it becomes a platform to deploy services even in embedded linux enviroment. There are different ways to install docker, one approach is to install using the pre-built binary distribution.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/linux/install-docker-binary.jpg&quot; alt=&quot;docker install&quot; /&gt;&lt;/p&gt;

&lt;p&gt;The following post shows what I did under ubuntu 16.04.&lt;/p&gt;

</content>
	</entry>
  
	<entry>
		<title>Scapy tool for network packet manipulation</title>
		<link type='text/html' href='http://weweng.github.io/2017/02/07/scapy-tool.html'/>
		<id>http://weweng.github.io/2017/02/07/scapy-tool.html</id>
		<updated>2017-02-07T00:00:00-08:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;Scapy is a powerful interactive packet manipulation program. It is able to forge or decode packets of a wide number of protocols, send them on the wire, capture them, match requests and replies, and much more.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/networking/scapy-tool.jpg&quot; alt=&quot;Scapy Tool&quot; /&gt;&lt;/p&gt;

</content>
	</entry>
  
	<entry>
		<title>Explore GIT Internals</title>
		<link type='text/html' href='http://weweng.github.io/2017/01/16/git-internal.html'/>
		<id>http://weweng.github.io/2017/01/16/git-internal.html</id>
		<updated>2017-01-16T00:00:00-08:00</updated>

		<author>
			<name>Wenwei Weng</name>
			<uri>http://weweng.github.io/</uri>
		</author>

		<content type='html'>&lt;p&gt;GIT is becoming widely used as SCM tool. I have been always interested in SCM tools which make me feel good if I know exactly where is my code and in case if I need made some change or track when/how the change is introduced. To get know better, I explored the internals of GIT, which is actaully very interesting.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;/uploads/git/git-internal-1.jpg&quot; alt=&quot;GIT Internal 1&quot; /&gt;&lt;/p&gt;

</content>
	</entry>
  
</feed>
